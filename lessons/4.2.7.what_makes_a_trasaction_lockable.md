Q2: what makes a transaction lockable?

**Answer:**

A transaction is **lockable** if it can acquire **all** the account locks it needs without conflicts. The `check_locks()` function determines this by verifying that **every account** the transaction accesses can be locked according to the conflict rules.

**Location:** `/home/ubuntu/vm/agave_v1/core/src/banking_stage/read_write_account_set.rs`

**Code:**
```rust
/// Returns true if all account locks were available and false otherwise.
pub fn check_locks(&self, message: &impl SVMMessage) -> bool {
    message
        .account_keys()           // Get all account keys from transaction
        .iter()                   // Iterate over accounts
        .enumerate()              // Get (index, pubkey) pairs
        .all(|(index, pubkey)| {  // Check ALL accounts can be locked
            if message.is_writable(index) {  // Use index to check if writable
                self.can_write(pubkey)       // Check write lock conflicts
            } else {
                self.can_read(pubkey)        // Check read lock conflicts
            }
        })
}
```

**What Makes a Transaction Lockable:**

A transaction is lockable if **ALL** of its accounts can be locked. The function uses `.all()` which means:

1. **Every account must pass** - If even one account has a conflict, the transaction is **not lockable**
2. **Different rules for writable vs read-only accounts** - Each account is checked according to its access type

**Lockability Rules:**

### For **Writable Accounts** (`can_write()`):
```rust
fn can_write(&self, pubkey: &Pubkey) -> bool {
    !self.write_set.contains(pubkey) && !self.read_set.contains(pubkey)
}
```

A writable account is lockable if:
- ✅ Account is **not write-locked** (`!write_set.contains(pubkey)`)
- ✅ Account is **not read-locked** (`!read_set.contains(pubkey)`)

**Conflicts that make it NOT lockable:**
- ❌ Account is already write-locked (Write-Write conflict)
- ❌ Account is already read-locked (Read-Write conflict)

### For **Read-Only Accounts** (`can_read()`):
```rust
fn can_read(&self, pubkey: &Pubkey) -> bool {
    !self.write_set.contains(pubkey)
}
```

A read-only account is lockable if:
- ✅ Account is **not write-locked** (`!write_set.contains(pubkey)`)

**Conflicts that make it NOT lockable:**
- ❌ Account is already write-locked (Write-Read conflict)

**Non-conflicts (allowed):**
- ✅ Account is read-locked (Read-Read is allowed - parallel reads)
- ✅ Account is unlocked (no conflicts)

**How It Works:**

1. **Extract all accounts** - `message.account_keys()` gets all accounts the transaction needs
2. **Check each account** - For each account:
   - Determine if it's writable using `message.is_writable(index)`
   - Call appropriate check: `can_write()` or `can_read()`
3. **Require ALL to pass** - `.all()` ensures every account passes its check
4. **Return result** - `true` if all accounts are lockable, `false` if any conflict exists

**Example Scenarios:**

### ✅ **Lockable Transaction:**
```
Transaction wants:
- Account A (writable) - not locked → ✅ can_write() = true
- Account B (read-only) - not locked → ✅ can_read() = true
- Account C (read-only) - read-locked → ✅ can_read() = true (parallel reads OK)

Result: check_locks() = true (ALL accounts lockable)
```

### ❌ **NOT Lockable Transaction:**
```
Transaction wants:
- Account A (writable) - not locked → ✅ can_write() = true
- Account B (writable) - write-locked → ❌ can_write() = false
- Account C (read-only) - not locked → ✅ can_read() = true

Result: check_locks() = false (Account B conflict - transaction NOT lockable)
```

### ❌ **NOT Lockable Transaction (read conflict):**
```
Transaction wants:
- Account A (read-only) - write-locked → ❌ can_read() = false

Result: check_locks() = false (Account A conflict - transaction NOT lockable)
```

**Key Points:**

1. **All-or-nothing**: A transaction is lockable only if **every single account** it needs can be locked
2. **Writable accounts are stricter**: They require the account to be completely unlocked (no read or write locks)
3. **Read-only accounts are more permissive**: They only conflict with write locks, allowing parallel reads
4. **Early termination**: `.all()` short-circuits on the first conflict, making it efficient

**Usage in Scheduling:**

The `check_locks()` function is used during transaction scheduling to determine if a transaction can proceed:

```rust
// In prio_graph_scheduler.rs:396
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

If `check_locks()` returns `false`, the transaction is **not lockable** and becomes unschedulable, preventing it from being scheduled until conflicts clear.

**Summary:**

A transaction is **lockable** if:
- ✅ **All** its accounts can be locked
- ✅ **Writable accounts**: Must be completely unlocked (no read or write locks)
- ✅ **Read-only accounts**: Must not be write-locked (read locks are OK)
- ✅ Uses `.all()` to ensure **every account** passes the conflict check

If **any** account has a conflict, the transaction is **not lockable** and cannot be scheduled.