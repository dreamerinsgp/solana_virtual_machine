Q1: key components?

1) The SVM includes the sBPF (Solana Berkeley Packet Filter) virtual machine
2) Runtime components for transaction execution
3) Banking stage scheduler
4) Account database (AccountsDB)


The SVM is a pipeline of subsystems that work together to execute transactions safely and efficiently. The Bank orchestrates execution for a specific slot, managing account state, enforcing consensus rules, and coordinating between the Banking Stage and persistent storage (i.e., AccountsDB). Each Bank represents the state of all accounts at a specific slot and progresses through three lifecycles: active (i.e., open to new transactions), frozen (i.e., not open to new transactions as the slot is complete), and rooted (i.e., part of the canonical chain).

The Banking Stage is where transaction execution happens within a validator’s Transaction Processing Unit (TPU). It receives verified transactions from the SigVerify stage, buffers them, and schedules them for parallel execution using conflict detection on account locks. Worker threads in the Banking Stage process batches of non-conflicting transactions, calling into the Bank’s execution methods to load accounts, provision sBPF VM instances for each instruction, execute program bytecode, and collect results. The Banking Stage continues to process batches of non-conflicting transactions until the Bank is frozen at the slot boundary. Note that batches are distinct from entries, which are the recorded units of transactions written to the ledger for replication and consensus.

The BPF Loaders manage the program lifecycle: deployment, JIT compilation, upgrades, and execution. When an instruction targets a given program, an sBPF VM is provisioned with its own memory regions and compute budget, and execution is handed off to the program’s bytecode.

The sBPF VM is the sandboxed execution environment where program bytecode actually runs. It is derived from Linux’s eBPF and uses a register-based architecture with 11 general-purpose registers. The VM enforces memory isolation through five distinct memory regions, each with explicit bounds and permissions. The VM also meters compute unit consumption to prevent runaway execution and dispatches system calls for privileged operations such as cryptography, logging, or Cross-Program Invocations (CPIs).

The AccountsDB is the persistent state layer where all account data lives. Account state is loaded in before execution, leveraging caches to avoid repeated disk reads for frequently accessed accounts. After successful execution, updates are committed back to AccountsDB. If execution fails, all state changes are reverted atomically.

Together, these components form the SVM, a decoupled, reusable execution engine.

