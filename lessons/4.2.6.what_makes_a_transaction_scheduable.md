# What Makes a Transaction Schedulable

Q1: tell me the datastructure of blocking_locks and a transaction?

**Answer:**

## Data Structure: `blocking_locks`

**Type:** `ReadWriteAccountSet`

**Location:** `agave_v1/core/src/banking_stage/read_write_account_set.rs:5-10`

```rust
/// Wrapper struct to accumulate locks for a batch of transactions.
#[derive(Debug, Default)]
pub struct ReadWriteAccountSet {
    /// Set of accounts that are locked for read
    read_set: AHashSet<Pubkey>,
    /// Set of accounts that are locked for write
    write_set: AHashSet<Pubkey>,
}
```

### Structure Breakdown:

**Fields:**
- `read_set: AHashSet<Pubkey>` - Hash set of account public keys that are read-locked
- `write_set: AHashSet<Pubkey>` - Hash set of account public keys that are write-locked

**Purpose:**
- Tracks accounts locked by **unschedulable transactions**
- Used to prevent priority inversion (lower-priority transactions can't jump ahead of blocked higher-priority ones)

**Operations:**
```rust
// Check if transaction can acquire locks
pub fn check_locks(&self, message: &impl SVMMessage) -> bool

// Add transaction's accounts to the lock sets
pub fn take_locks(&mut self, message: &impl SVMMessage) -> bool

// Clear all locks
pub fn clear(&mut self)
```

**Example:**
```rust
let mut blocking_locks = ReadWriteAccountSet::default();

// Transaction A (blocked) wants Account X (write)
blocking_locks.take_locks(transaction_a);
// blocking_locks.write_set = {AccountX}

// Transaction B arrives, wants Account X (write)
if !blocking_locks.check_locks(transaction_b) {
    // Conflict detected! Transaction B also becomes blocked
    blocking_locks.take_locks(transaction_b);
}
```

---

## Data Structure: `transaction`

**Type:** `&Tx` where `Tx: TransactionWithMeta`

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:395`

```rust
let transaction = transaction_state.transaction();
// Returns: &Tx where Tx: TransactionWithMeta
```

### Type Hierarchy:

```
TransactionWithMeta (trait)
    ↓
    extends SVMTransaction (trait)
        ↓
        extends SVMMessage (trait)
            ↓
            extends SVMStaticMessage (trait)
```

### TransactionWithMeta Trait

**Location:** `agave_v1/runtime-transaction/src/transaction_with_meta.rs:8-17`

```rust
pub trait TransactionWithMeta: StaticMeta + SVMTransaction {
    fn as_sanitized_transaction(&self) -> Cow<'_, SanitizedTransaction>;
    fn to_versioned_transaction(&self) -> VersionedTransaction;
}
```

### SVMTransaction Trait

**Location:** `agave_v1/svm-transaction/src/svm_transaction.rs`

```rust
pub trait SVMTransaction: SVMMessage {
    fn signature(&self) -> &Signature;
    fn signatures(&self) -> &[Signature];
    // ... other methods
}
```

### SVMMessage Trait (Key for Conflict Detection)

**Location:** `agave_v1/svm-transaction/src/svm_message.rs:73-148`

```rust
pub trait SVMMessage: Debug + SVMStaticMessage {
    /// Return the account keys.
    fn account_keys(&self) -> AccountKeys<'_>;

    /// Returns `true` if the account at `index` is writable.
    fn is_writable(&self, index: usize) -> bool;

    /// Returns `true` if the account at `index` is signer.
    fn is_signer(&self, index: usize) -> bool;

    /// Returns true if the account at the specified index is invoked as a
    /// program in top-level instructions of this message.
    fn is_invoked(&self, key_index: usize) -> bool;
}
```

### TransactionState Structure

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/transaction_state.rs:14-26`

```rust
pub(crate) struct TransactionState<Tx> {
    /// If `Some`, the transaction is available for scheduling.
    /// If `None`, the transaction is currently scheduled or being processed.
    transaction: Option<Tx>,
    /// Tracks information on the maximum age the transaction's pre-processing
    /// is valid for. This includes sanitization features, as well as resolved
    /// address lookups.
    max_age: MaxAge,
    /// Priority of the transaction.
    priority: u64,
    /// Estimated cost of the transaction.
    cost: u64,
}
```

**Method:**
```rust
pub(crate) fn transaction(&self) -> &Tx {
    self.transaction
        .as_ref()
        .expect("transaction is not pending")
}
```

### What the Transaction Contains (via SVMMessage)

The transaction implements `SVMMessage`, which provides:

1. **Account Keys** (`account_keys()`):
   ```rust
   fn account_keys(&self) -> AccountKeys<'_>
   ```
   - Returns all account public keys the transaction will access
   - Ordered array: signers → non-signers, writable → readonly

2. **Account Metadata** (`is_writable(index)`, `is_signer(index)`):
   ```rust
   fn is_writable(&self, index: usize) -> bool
   fn is_signer(&self, index: usize) -> bool
   ```
   - Determines if account at `index` is writable or readonly
   - Determines if account at `index` is a signer

3. **Instructions** (`instructions_iter()`):
   ```rust
   fn instructions_iter(&self) -> impl Iterator<Item = SVMInstruction<'_>>
   ```
   - Returns instructions in the transaction

## How They Interact in Conflict Detection

**Code:** `agave_v1/core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:393-399`

```rust
// Check if this transaction conflicts with any blocked transactions
let transaction = transaction_state.transaction();
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

### Step-by-Step Interaction:

1. **Get transaction reference:**
   ```rust
   let transaction = transaction_state.transaction();
   // Type: &Tx where Tx: TransactionWithMeta
   // Transaction implements SVMMessage trait
   ```

2. **Check conflicts:**
   ```rust
   blocking_locks.check_locks(transaction)
   // Internally calls:
   //   transaction.account_keys() → AccountKeys<'_>
   //   transaction.is_writable(index) → bool
   //   Checks against blocking_locks.read_set and write_set
   ```

3. **If conflict detected:**
   ```rust
   blocking_locks.take_locks(transaction)
   // Adds transaction's accounts to blocking_locks:
   //   - Write accounts → write_set
   //   - Read accounts → read_set
   ```

### Internal Implementation of `check_locks`:

**Location:** `agave_v1/core/src/banking_stage/read_write_account_set.rs:14-26`

```rust
pub fn check_locks(&self, message: &impl SVMMessage) -> bool {
    message
        .account_keys()           // Get all account keys from transaction
        .iter()                   // Iterate over accounts
        .enumerate()              // Get (index, pubkey) pairs
        .all(|(index, pubkey)| {  // Check ALL accounts can be locked
            if message.is_writable(index) {  // Use index to check if writable
                self.can_write(pubkey)       // Check write lock conflicts
            } else {
                self.can_read(pubkey)        // Check read lock conflicts
            }
        })
}
```

**What happens:**
- `transaction.account_keys()` returns `AccountKeys<'_>` (array of `Pubkey`)
- For each account, uses `transaction.is_writable(index)` to determine access type
- Checks if account conflicts with `blocking_locks.read_set` or `write_set`
- Returns `true` only if **all accounts** can be locked

## Data Structure Summary

### `blocking_locks: ReadWriteAccountSet`

```rust
ReadWriteAccountSet {
    read_set: AHashSet<Pubkey>,   // Read-locked accounts
    write_set: AHashSet<Pubkey>,  // Write-locked accounts
}
```

**Purpose:** Track accounts locked by unschedulable transactions  
**Operations:** Check conflicts, add locks, clear locks  
**Lifecycle:** Cleared at start of each scheduling pass

### `transaction: &Tx` (where `Tx: TransactionWithMeta`)

```rust
TransactionState<Tx> {
    transaction: Option<Tx>,  // The actual transaction
    max_age: MaxAge,
    priority: u64,
    cost: u64,
}

// Transaction implements:
SVMMessage {
    account_keys() -> AccountKeys<'_>,  // All account pubkeys
    is_writable(index) -> bool,         // Account access type
    is_signer(index) -> bool,           // Account signer status
    // ... other methods
}
```

**Purpose:** Represents a transaction with account access information  
**Key Methods:** `account_keys()`, `is_writable(index)`, `is_signer(index)`  
**Lifecycle:** Wrapped in `TransactionState`, taken when scheduled

## Example: Conflict Detection Flow

```rust
// Initial state
let mut blocking_locks = ReadWriteAccountSet::default();
// blocking_locks.read_set = {}
// blocking_locks.write_set = {}

// Transaction A (high priority, blocked) wants Account X (write)
let transaction_a = transaction_state_a.transaction();
// transaction_a.account_keys() = [AccountX, AccountY]
// transaction_a.is_writable(0) = true  (AccountX is writable)
// transaction_a.is_writable(1) = false (AccountY is readonly)

blocking_locks.take_locks(transaction_a);
// blocking_locks.write_set = {AccountX}
// blocking_locks.read_set = {AccountY}

// Transaction B (lower priority) arrives, wants Account X (write)
let transaction_b = transaction_state_b.transaction();
// transaction_b.account_keys() = [AccountX]
// transaction_b.is_writable(0) = true

if !blocking_locks.check_locks(transaction_b) {
    // Check: AccountX is writable, but in write_set → Conflict!
    // Result: false (cannot schedule)
    
    blocking_locks.take_locks(transaction_b);
    // Transaction B also becomes blocked
    // blocking_locks.write_set = {AccountX} (unchanged, already there)
}
```

## Key Points

1. **`blocking_locks`** is a **simple tracking structure** with two hash sets
   - Tracks which accounts are locked by unschedulable transactions
   - Used for priority preservation

2. **`transaction`** is a **rich object** implementing multiple traits
   - Provides account keys and metadata via `SVMMessage`
   - Contains full transaction data (signatures, instructions, etc.)
   - Wrapped in `TransactionState` for scheduling lifecycle

3. **Interaction** happens through trait methods:
   - `transaction.account_keys()` → Gets account list
   - `transaction.is_writable(index)` → Determines access type
   - `blocking_locks.check_locks(transaction)` → Checks conflicts

4. **Conflict detection** is **index-based**:
   - Uses account index to look up metadata (`is_writable(index)`)
   - Checks account pubkey against lock sets
   - Returns `true` only if ALL accounts can be locked

This design allows efficient conflict detection **without executing the transaction** - all information needed is available through the `SVMMessage` trait interface.


