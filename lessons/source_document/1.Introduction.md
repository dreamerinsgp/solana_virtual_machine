Introduction
    The Solana Virtual Machine (SVM) is one of the most misunderstood systems in blockchains today. Unlike the Ethereum Virtual Machine (EVM), which refers unambiguously to an opcode executor, the term SVM encompasses an entire transaction execution pipeline, from the Banking Stage scheduler to the sBPF bytecode interpreter itself. This ambiguity reflects Solana’s architectural difference: there is no traditional specification that defines “the SVM” in isolation. The only specification that comes close pertains to the Solana Virtual Machine Instruction Set Architecture (SVM ISA), which describes how sBPF bytecode must execute, but says nothing about the broader runtime.

    This article aims to serve as a comprehensive reference for what the SVM is, how it works, and why it’s fundamentally different from the perspective of Anza’s Agave validator implementation. Exploration into how Firedancer’s client operates, as well as their custom virtual machine implementation that adheres to the SVM ISA, is outside the scope of this work.

    We are interested in examining the actual codebase, rather than some abstract specification. We trace the complete execution pipeline—how Rust source code compiles through LLVM to sBPF bytecode, how programs are deployed and verified, how the runtime provisions isolated execution environments for parallel execution, and how transactions interact with deployed bytecode.

    The first few sections contextualize the SVM’s ambiguity and give a high-level overview of how it works. The remainder of the article is intended for a more technical audience seeking a rigorous understanding of Solana’s execution layer.

