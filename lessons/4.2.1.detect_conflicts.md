Q1: what conflicts does it check?

**Answer:**

The `check_locks()` function checks for **account lock conflicts** between a new transaction and already-locked accounts. It verifies if a transaction can acquire all the locks it needs by checking each account the transaction wants to access.

**Location:** `/home/ubuntu/vm/agave_v1/core/src/banking_stage/read_write_account_set.rs`

**Code:**
```rust
/// Returns true if all account locks were available and false otherwise.
pub fn check_locks(&self, message: &impl SVMMessage) -> bool {
    message
        .account_keys()
        .iter()
        .enumerate()
        .all(|(index, pubkey)| {
            if message.is_writable(index) {
                self.can_write(pubkey)
            } else {
                self.can_read(pubkey)
            }
        })
}
```

**Conflicts Detected:**

1. **Write-Write Conflict** (lines 56-58, `can_write()`):
   - **Conflict**: A transaction wants to write to an account that is already write-locked
   - **Check**: `!self.write_set.contains(pubkey)` - write is blocked if account is in write_set
   - **Result**: Returns `false`, transaction cannot proceed

2. **Read-Write Conflict** (lines 56-58, `can_write()`):
   - **Conflict**: A transaction wants to write to an account that is currently read-locked
   - **Check**: `!self.read_set.contains(pubkey)` - write is blocked if account is in read_set
   - **Result**: Returns `false`, transaction cannot proceed

3. **Write-Read Conflict** (lines 51-53, `can_read()`):
   - **Conflict**: A transaction wants to read from an account that is currently write-locked
   - **Check**: `!self.write_set.contains(pubkey)` - read is blocked if account is in write_set
   - **Result**: Returns `false`, transaction cannot proceed

4. **Read-Read Non-Conflict** (lines 51-53, `can_read()`):
   - **No Conflict**: Multiple transactions can read the same account simultaneously
   - **Check**: `can_read()` returns `true` as long as account is not write-locked
   - **Result**: Returns `true`, allows parallel reads

**How it works:**

- The function iterates through **all accounts** the transaction needs (`message.account_keys()`)
- For each account, it checks:
  - If account is **writable**: calls `can_write()` which requires account to be in neither `write_set` nor `read_set`
  - If account is **read-only**: calls `can_read()` which only requires account to not be in `write_set`
- Uses `.all()` to ensure **every account** can be locked (no conflicts)
- Returns `true` only if **all accounts** pass the conflict check, `false` if any conflict is detected

**Conflict Matrix:**

| Current Lock | Requested Lock | Conflict? | Result |
|--------------|----------------|-----------|--------|
| None | Read | No | ✅ Allowed |
| None | Write | No | ✅ Allowed |
| Read | Read | No | ✅ Allowed (parallel reads) |
| Read | Write | **Yes** | ❌ Blocked |
| Write | Read | **Yes** | ❌ Blocked |
| Write | Write | **Yes** | ❌ Blocked |

This ensures that:
- Multiple transactions can read the same account in parallel
- Only one transaction can write to an account at a time
- No transaction can read while another is writing to the same account




Q2: when add locks to these accounts ? [TODO: example]

**Answer:**

Locks are added to accounts via `take_locks()` in **two different contexts** during transaction scheduling:

**Location:** `/home/ubuntu/vm/agave_v1/core/src/banking_stage/read_write_account_set.rs`

**Code:**
```rust
/// Add all account locks.
/// Returns true if all account locks were available and false otherwise.
pub fn take_locks(&mut self, message: &impl SVMMessage) -> bool {
    message
        .account_keys()
        .iter()
        .enumerate()
        .fold(true, |all_available, (index, pubkey)| {
            if message.is_writable(index) {
                all_available & self.add_write(pubkey)
            } else {
                all_available & self.add_read(pubkey)
            }
        })
}
```

**When locks are added:**

### 1. **When transactions become unschedulable** (Priority Graph Scheduler)

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs`

Locks are added to `blocking_locks` (a `ReadWriteAccountSet`) when a transaction **cannot be scheduled** due to conflicts. This happens in three scenarios:

**a) Transaction conflicts with already-blocked transactions** (line 397):
```rust
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);  // Add locks to blocking_locks
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

**b) Transaction fails to acquire thread-level locks** (line 420):
```rust
Err(TryLockError::MultipleConflicts) => {
    blocking_locks.take_locks(transaction);  // Add locks to blocking_locks
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

**c) Transaction fails due to thread constraints** (line 424):
```rust
Err(TryLockError::ThreadNotAllowed) => {
    blocking_locks.take_locks(transaction);  // Add locks to blocking_locks
    return Err(TransactionSchedulingError::UnschedulableThread);
}
```

**Purpose:** The `blocking_locks` set tracks accounts that are locked by **unschedulable transactions**. This prevents other transactions from being scheduled if they conflict with these blocked transactions, ensuring fairness and preventing starvation.

**Lifecycle:** `blocking_locks` is:
- **Initialized** at the start of each scheduling pass (line 154): `let mut blocking_locks = ReadWriteAccountSet::default();`
- **Cleared** implicitly at the start of the next scheduling pass (fresh initialization)

### 2. **When transactions are successfully scheduled** (Greedy Scheduler)

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/greedy_scheduler.rs`

In the greedy scheduler, locks are added to `working_account_set` when a transaction is **successfully scheduled** (line 188):

```rust
Ok(TransactionSchedulingInfo { ... }) => {
    if !relax_intrabatch_account_locks {
        assert!(
            self.working_account_set.take_locks(&transaction),  // Add locks
            "locks must be available"
        );
    }
    // ... schedule transaction ...
}
```

**Purpose:** The `working_account_set` tracks locks for transactions currently being scheduled in the current batch, ensuring no conflicts within the batch.

**Lifecycle:** `working_account_set` is:
- **Cleared** when a batch reaches target size (line 206): `self.working_account_set.clear();`
- **Cleared** at the end of scheduling (line 225): `self.working_account_set.clear();`

### **Two-Level Locking System:**

1. **`ReadWriteAccountSet` (blocking_locks/working_account_set)**: 
   - Tracks locks for scheduling decisions
   - Used to prevent conflicts during scheduling
   - Cleared between scheduling passes/batches

2. **`ThreadAwareAccountLocks` (account_locks)**:
   - Actual thread-level locks for executing transactions
   - Acquired via `account_locks.try_lock_accounts()` (line 412)
   - Released when transactions complete execution

**Summary:**

- **`take_locks()`** adds accounts to tracking sets (`blocking_locks` or `working_account_set`) for **scheduling purposes**
- It's called when transactions become **unschedulable** (to track conflicts) or when they're **scheduled** (to track batch locks)
- The actual **execution locks** are acquired separately via `ThreadAwareAccountLocks.try_lock_accounts()`
- These tracking sets are **cleared** between scheduling passes/batches to start fresh



Q3: what's the meaning of becoming unschedulable and scheduled in this context?

**Answer:**

In the Banking Stage transaction scheduler, "scheduled" and "unschedulable" refer to whether a transaction can be **immediately assigned to a worker thread for execution** during the current scheduling pass.

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/`

### **Scheduled Transaction**

A transaction becomes **scheduled** when it successfully:

1. **Passes conflict checks** - No conflicts with blocked transactions (`blocking_locks.check_locks()`)
2. **Acquires thread-level account locks** - Successfully locks accounts on a specific thread (`account_locks.try_lock_accounts()`)
3. **Gets assigned to a worker thread** - Assigned to a thread ID for execution
4. **Added to a batch** - Placed in a batch for that thread
5. **Sent to worker thread** - Batch is sent via `consume_work_senders[thread_id]` for execution

**Code flow:**
```rust
// In try_schedule_transaction() - lines 412-427
let thread_id = match account_locks.try_lock_accounts(...) {
    Ok(thread_id) => {
        // Transaction is scheduled!
        let (transaction, max_age) = transaction_state.take_transaction_for_scheduling();
        Ok(TransactionSchedulingInfo {
            thread_id,
            transaction,
            max_age,
            cost,
        })
    }
    Err(...) => {
        // Transaction becomes unschedulable
        return Err(TransactionSchedulingError::UnschedulableConflicts);
    }
};

// In schedule() - lines 267-280
Ok(TransactionSchedulingInfo { thread_id, transaction, max_age, cost }) => {
    num_scheduled += 1;
    self.common.batches.add_transaction_to_batch(thread_id, id.id, transaction, max_age, cost);
    // Later: send_batch(thread_id) sends it to worker thread
}
```

**State change:**
- Transaction is **taken** from `TransactionState` (becomes `None`)
- Transaction moves from "available for scheduling" to "currently scheduled or being processed"
- Transaction will be executed by the assigned worker thread

### **Unschedulable Transaction**

A transaction becomes **unschedulable** when it **cannot be scheduled** in the current pass due to:

1. **Account lock conflicts** (`UnschedulableConflicts`):
   - Conflicts with already-blocked transactions (`blocking_locks.check_locks()` fails)
   - Conflicts with transactions already executing on threads (`try_lock_accounts()` fails with `MultipleConflicts`)

2. **Thread constraints** (`UnschedulableThread`):
   - No available threads that can handle the transaction (`try_lock_accounts()` fails with `ThreadNotAllowed`)
   - Threads may be at capacity (max compute units reached)

**Code flow:**
```rust
// In try_schedule_transaction() - lines 396-399, 419-426
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);  // Track the conflict
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}

match account_locks.try_lock_accounts(...) {
    Err(TryLockError::MultipleConflicts) => {
        blocking_locks.take_locks(transaction);
        return Err(TransactionSchedulingError::UnschedulableConflicts);
    }
    Err(TryLockError::ThreadNotAllowed) => {
        blocking_locks.take_locks(transaction);
        return Err(TransactionSchedulingError::UnschedulableThread);
    }
}

// In schedule() - lines 259-266
Err(TransactionSchedulingError::UnschedulableConflicts) => {
    num_unschedulable_conflicts += 1;
    unschedulable_ids.push(id);  // Keep for retry
}
```

**State change:**
- Transaction **remains** in `TransactionState` (still `Some(transaction)`)
- Transaction is **pushed back** into the queue (line 326): `container.push_ids_into_queue(unschedulable_ids)`
- Transaction will be **retried** in the next scheduling pass when conflicts may have cleared

### **Key Differences**

| Aspect | Scheduled | Unschedulable |
|--------|-----------|---------------|
| **Conflict Check** | ✅ Passes | ❌ Fails |
| **Account Locks** | ✅ Acquired | ❌ Cannot acquire |
| **Thread Assignment** | ✅ Assigned to thread | ❌ No thread available |
| **Transaction State** | Taken (`None`) | Remains (`Some`) |
| **Next Step** | Sent to worker thread for execution | Pushed back to queue for retry |
| **When Retried** | N/A (already executing) | Next scheduling pass |

### **Why Unschedulable Transactions Are Retried**

Unschedulable transactions are **not discarded** - they're retried because:

1. **Conflicts are temporary** - Transactions currently executing will complete and release locks
2. **Fairness** - Prevents starvation of lower-priority transactions
3. **Resource availability** - Threads may become available as work completes
4. **Priority ordering** - Higher priority transactions may complete first, freeing resources

**Retry mechanism** (line 326):
```rust
// Push unschedulable ids back into the container
container.push_ids_into_queue(unschedulable_ids.into_iter());
```

These transactions will be considered again in the **next scheduling pass**, potentially after:
- Currently executing transactions complete and release locks
- Threads finish their current batches
- Higher priority conflicting transactions are processed

### **Summary**

- **Scheduled** = Transaction is **immediately ready** for execution, assigned to a thread, and sent for processing
- **Unschedulable** = Transaction **cannot run now** due to conflicts or resource constraints, but will be **retried later** when conditions improve

The scheduler continuously attempts to schedule transactions, with unschedulable ones being retried until they can be scheduled or eventually fail permanently (e.g., transaction expires). 


Q4： why blocked transactions exist? what makes a transaction be blocked?

**Answer:**

"Blocked transactions" are **unschedulable transactions** whose account locks are tracked in `blocking_locks` to **prevent priority inversion** and maintain **fairness** in the scheduler.

**Location:** `agave_v1/core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs`

**Key Comment** (lines 149-152):
```rust
// Some transactions may be unschedulable due to multi-thread conflicts.
// These transactions cannot be scheduled until some conflicting work is completed.
// However, the scheduler should not allow other transactions that conflict with
// these transactions to be scheduled before them.
let mut blocking_locks = ReadWriteAccountSet::default();
```

### **What Makes a Transaction Become Blocked?**

A transaction becomes **blocked** (its locks added to `blocking_locks`) when it becomes **unschedulable** due to:

1. **Account lock conflicts** with transactions already executing on threads
2. **Thread capacity constraints** (no available threads)
3. **Conflicts with other already-blocked transactions**

**Code flow** (lines 396-398, 420-421, 424-425):
```rust
// When transaction conflicts with blocked transactions
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);  // Transaction becomes blocked
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}

// When transaction fails to acquire thread-level locks
Err(TryLockError::MultipleConflicts) => {
    blocking_locks.take_locks(transaction);  // Transaction becomes blocked
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

### **Why Blocked Transactions Exist: Preventing Priority Inversion**

The `blocking_locks` mechanism exists to solve a **priority inversion problem**:

**Problem Scenario (without blocking_locks):**

1. **Transaction A** (high priority, wants Account X) tries to schedule
2. **Transaction B** (low priority, currently executing, has Account X locked) is running
3. Transaction A becomes unschedulable (conflicts with B)
4. **Transaction C** (medium priority, also wants Account X) arrives
5. Transaction B finishes, releases Account X
6. **Without blocking_locks**: Transaction C could be scheduled before Transaction A, even though A has higher priority! ❌

**Solution (with blocking_locks):**

1. Transaction A becomes unschedulable → its locks added to `blocking_locks`
2. Transaction C arrives and checks `blocking_locks.check_locks()` (line 396)
3. Transaction C conflicts with `blocking_locks` (Account X is blocked by A)
4. Transaction C also becomes unschedulable → its locks added to `blocking_locks`
5. When Transaction B finishes, Transaction A (higher priority) gets scheduled first ✅
6. Then Transaction C can be scheduled

**Code that enforces this** (lines 394-399):
```rust
// Check if this transaction conflicts with any blocked transactions
let transaction = transaction_state.transaction();
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

### **How Blocked Transactions Work**

**Step 1: Transaction becomes unschedulable**
- Transaction tries to schedule but conflicts with executing transactions
- Its account locks are added to `blocking_locks` (line 397, 420, or 424)

**Step 2: Blocking other transactions**
- New transactions check `blocking_locks` before scheduling (line 396)
- If they conflict with `blocking_locks`, they also become unschedulable
- This creates a "chain" of blocked transactions that respect priority order

**Step 3: Unblocking when conflicts clear**
- When executing transactions complete, they release locks
- Blocked transactions are retried in the next scheduling pass (line 326)
- Higher priority blocked transactions get scheduled first (due to priority ordering in `PrioGraph`)

**Step 4: Clearing blocking_locks**
- `blocking_locks` is cleared at the start of each scheduling pass (line 154)
- Fresh start for the next round of scheduling

### **Example Scenario**

**Initial State:**
- **Tx A** (priority 100, wants Account X) - in queue
- **Tx B** (priority 50, wants Account X) - currently executing on Thread 1
- **Tx C** (priority 75, wants Account X) - in queue

**Scheduling Pass 1:**
1. Try to schedule Tx A → conflicts with Tx B (executing) → **Tx A becomes blocked**
   - `blocking_locks` = {Account X: write}
2. Try to schedule Tx C → conflicts with `blocking_locks` (Account X blocked by Tx A)
   - **Tx C also becomes blocked** (can't jump ahead of higher priority Tx A)
   - `blocking_locks` = {Account X: write} (still blocked by Tx A)

**After Tx B Completes:**
- Tx B releases Account X
- `blocking_locks` still tracks Tx A's claim

**Scheduling Pass 2:**
1. Try to schedule Tx A → no conflicts → **Tx A scheduled** ✅
2. Try to schedule Tx C → no conflicts → **Tx C scheduled** ✅

**Result:** Priority order maintained (A before C), even though both were blocked!

### **Key Benefits**

1. **Priority Preservation**: Higher priority transactions don't get "jumped" by lower priority ones
2. **Fairness**: Transactions are scheduled in priority order, even when blocked
3. **Prevents Starvation**: Lower priority transactions still get scheduled eventually (after higher priority ones)
4. **Deterministic Ordering**: Consistent scheduling order across scheduling passes

### **Summary**

- **Blocked transactions** = Unschedulable transactions whose account locks are tracked in `blocking_locks`
- **Purpose** = Prevent priority inversion by blocking conflicting transactions from being scheduled ahead of higher-priority blocked transactions
- **Mechanism** = `blocking_locks` acts as a "reservation system" that prevents lower-priority transactions from claiming accounts that higher-priority transactions are waiting for
- **Lifecycle** = Transactions become blocked when unschedulable, block others that conflict, and get retried in priority order when conflicts clear