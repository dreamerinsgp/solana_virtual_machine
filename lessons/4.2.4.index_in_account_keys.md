# Account Keys and Index Meaning

Q1: what account_keys contain ?

**Answer:**

`account_keys()` returns an `AccountKeys<'_>` which is a **flat array/slice of all account public keys** that the transaction will access, in a **specific order**.

**Location:** `agave_v1/svm-transaction/src/svm_message.rs:75`

```rust
fn account_keys(&self) -> AccountKeys<'_>;
```

## Account Keys Structure

`AccountKeys` contains **all account public keys** (`Pubkey`) that the transaction references, organized in a specific order:

### Account Ordering (Legacy and V0 Messages)

Accounts are ordered by their **role and access type**:

1. **Signed Writable Accounts** (index 0 to `num_required_signatures - num_readonly_signed_accounts - 1`)
   - Accounts that must sign the transaction AND are writable
   - Example: Fee payer (typically index 0)

2. **Signed Readonly Accounts** (index `num_required_signatures - num_readonly_signed_accounts` to `num_required_signatures - 1`)
   - Accounts that must sign the transaction BUT are readonly
   - Less common, but possible

3. **Unsigned Writable Accounts** (index `num_required_signatures` to `num_required_signatures + num_writable_unsigned_accounts - 1`)
   - Accounts that don't sign but are writable
   - Example: Accounts being modified by instructions

4. **Unsigned Readonly Accounts** (remaining indices)
   - Accounts that don't sign and are readonly
   - Example: Program IDs, accounts being read

### For V0 Messages (with Address Lookup Tables)

After the static accounts above, **address lookup table accounts** are appended:

5. **Lookup Table Writable Accounts** (from address lookup tables)
6. **Lookup Table Readonly Accounts** (from address lookup tables)

**Code Example:**
```rust
// From transaction-view/src/resolved_transaction_view.rs:98-109
let account_keys = AccountKeys::new(view.static_account_keys(), resolved_addresses);

for (index, key) in account_keys.iter().enumerate() {
    // index 0 to num_static_account_keys-1: static accounts
    // index num_static_account_keys onwards: lookup table accounts
}
```

## What's Contained

**`AccountKeys` contains:**
- **All account public keys** (`Pubkey`) the transaction will access
- **Ordered by role**: signers first, then non-signers; writable before readonly within each group
- **Includes both static and lookup table accounts** (for V0 messages)
- **Flat structure**: A simple slice/array, not nested

**Example:**
```rust
// Transaction with:
// - Fee payer (signer, writable) → index 0
// - Account A (signer, writable) → index 1  
// - Account B (unsigned, writable) → index 2
// - Program ID (unsigned, readonly) → index 3
// - Account C from lookup table (writable) → index 4

account_keys() = [FeePayer, AccountA, AccountB, ProgramID, AccountC]
```

---

Q2: what index means ?

**Answer:**

The **`index`** is the **position** (0-based) of an account in the `account_keys()` array. It's used to:

1. **Look up account metadata** via `is_writable(index)` and `is_signer(index)`
2. **Reference accounts in instructions** (instructions use indices, not pubkeys directly)
3. **Determine account access type** based on its position in the ordered array

**Location:** `agave_v1/core/src/banking_stage/read_write_account_set.rs:14-26`

```rust
pub fn check_locks(&self, message: &impl SVMMessage) -> bool {
    message
        .account_keys()
        .iter()
        .enumerate()  // ← Creates (index, pubkey) pairs
        .all(|(index, pubkey)| {
            if message.is_writable(index) {  // ← Uses index to check if writable
                self.can_write(pubkey)
            } else {
                self.can_read(pubkey)
            }
        })
}
```

## How Index Determines Account Properties

The index position determines account properties based on the `MessageHeader` structure:

**MessageHeader fields:**
- `num_required_signatures`: Number of accounts that must sign
- `num_readonly_signed_accounts`: Number of signers that are readonly
- `num_readonly_unsigned_accounts`: Number of non-signers that are readonly

**Determining `is_writable(index)`:**
```rust
// From transaction-view/src/resolved_transaction_view.rs:109-121
for (index, key) in account_keys.iter().enumerate() {
    let is_requested_write = {
        // Lookup table accounts (index >= num_static_account_keys)
        if index >= num_static_account_keys {
            let loaded_address_index = index - num_static_account_keys;
            loaded_address_index < num_writable_lookup_accounts
        }
        // Unsigned static accounts (index >= num_signed_accounts)
        else if index >= num_signed_accounts {
            let unsigned_account_index = index - num_signed_accounts;
            unsigned_account_index < num_writable_unsigned_static_accounts
        }
        // Signed accounts (index < num_signed_accounts)
        else {
            index < num_writable_signed_static_accounts
        }
    };
}
```

**Determining `is_signer(index)`:**
```rust
// Signers are at the beginning of the array
is_signer(index) = index < num_required_signatures
```

## Index Usage in Code

### 1. Conflict Detection

**Code:** `agave_v1/core/src/banking_stage/read_write_account_set.rs:14-26`

```rust
message
    .account_keys()
    .iter()
    .enumerate()  // (index, pubkey)
    .all(|(index, pubkey)| {
        if message.is_writable(index) {  // Index determines write access
            self.can_write(pubkey)
        } else {
            self.can_read(pubkey)
        }
    })
```

**What happens:**
- Iterates through all accounts with their indices
- Uses `index` to call `is_writable(index)` to determine access type
- Checks conflicts based on access type

### 2. Separating Write/Read Accounts

**Code:** `agave_v1/core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:402-410`

```rust
let account_keys = transaction.account_keys();
let write_account_locks = account_keys
    .iter()
    .enumerate()
    .filter_map(|(index, key)| transaction.is_writable(index).then_some(key));
let read_account_locks = account_keys
    .iter()
    .enumerate()
    .filter_map(|(index, key)| (!transaction.is_writable(index)).then_some(key));
```

**What happens:**
- Uses `index` to determine if account is writable
- Separates accounts into write locks vs read locks
- Critical for parallel execution conflict detection

### 3. Instruction Account References

**In instructions, accounts are referenced by index, not pubkey:**

```rust
// Instruction structure
struct CompiledInstruction {
    program_id_index: u8,  // Index into account_keys
    accounts: Vec<u8>,     // Indices into account_keys
    data: Vec<u8>,
}
```

**Example:**
```rust
// account_keys() = [FeePayer, AccountA, AccountB, ProgramID]
// Instruction: transfer from AccountA to AccountB
// accounts = [1, 2]  // Indices, not pubkeys!
//   - 1 = AccountA (source)
//   - 2 = AccountB (destination)
```

## Index Range Examples

**Example Transaction:**
- `num_required_signatures = 2` (FeePayer + AccountA)
- `num_readonly_signed_accounts = 0` (both signers are writable)
- `num_readonly_unsigned_accounts = 1` (ProgramID is readonly)
- Static accounts: 4 total

**Account Keys Array:**
```
Index | Account      | is_signer | is_writable | Role
------|--------------|-----------|-------------|------------------
  0   | FeePayer     | true      | true        | Signed writable
  1   | AccountA     | true      | true        | Signed writable
  2   | AccountB      | false     | true        | Unsigned writable
  3   | ProgramID     | false     | false       | Unsigned readonly
```

**Index-based checks:**
- `is_signer(0)` → `true` (index < 2)
- `is_signer(1)` → `true` (index < 2)
- `is_signer(2)` → `false` (index >= 2)
- `is_writable(0)` → `true` (signed writable)
- `is_writable(2)` → `true` (unsigned writable)
- `is_writable(3)` → `false` (unsigned readonly)

## Key Points

1. **Index is position-based**: The index is simply the position in the `account_keys()` array (0-based)

2. **Index determines metadata**: `is_writable(index)` and `is_signer(index)` use the index to look up account properties based on MessageHeader structure

3. **Index used in instructions**: Instructions reference accounts by index, not by pubkey directly (saves space)

4. **Index order matters**: The order of accounts in `account_keys()` follows a specific pattern (signers → non-signers, writable → readonly)

5. **Index enables efficient lookups**: Instead of searching by pubkey, the system can directly access account metadata using the index

## Summary

- **`account_keys()`** contains: A flat array of all account public keys (`Pubkey`) in a specific order (signers first, then non-signers; writable before readonly)

- **`index`** means: The 0-based position in the `account_keys()` array, used to:
  - Determine if account is writable (`is_writable(index)`)
  - Determine if account is signer (`is_signer(index)`)
  - Reference accounts in instructions (instructions use indices)
  - Efficiently look up account metadata without searching by pubkey

The index-based system is **efficient** because it allows O(1) lookups of account metadata and enables compact instruction encoding (using indices instead of full pubkeys).
