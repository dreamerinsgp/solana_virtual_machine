Q1: what actually happens when we lock accounts?

**Answer:**

When accounts are locked, the system updates **thread-aware lock data structures** that track which threads have access to which accounts. This involves creating or updating entries in a hashmap, incrementing lock counts, and updating thread sets to enable conflict detection and thread assignment.

**Location:** `agave_v1/scheduling-utils/src/thread_aware_account_locks.rs`

## Data Structures Updated

### 1. **Main Lock Storage: `locks: AHashMap<Pubkey, AccountLocks>`**

```rust
// From thread_aware_account_locks.rs:59-65
pub struct ThreadAwareAccountLocks {
    num_threads: usize,
    locks: AHashMap<Pubkey, AccountLocks>,  // Maps account → lock info
}
```

**What it stores:**
- **Key**: `Pubkey` - The account public key
- **Value**: `AccountLocks` - Lock information for that account

### 2. **Account Lock Information: `AccountLocks`**

```rust
// From thread_aware_account_locks.rs:40-43
struct AccountLocks {
    write_locks: Option<AccountWriteLocks>,  // Write lock info (if any)
    read_locks: Option<AccountReadLocks>,   // Read lock info (if any)
}
```

**What it tracks:**
- **Write locks**: Exclusive locks held by a single thread
- **Read locks**: Shared locks that can be held by multiple threads

### 3. **Write Lock Structure: `AccountWriteLocks`**

```rust
// From thread_aware_account_locks.rs:23-26
struct AccountWriteLocks {
    thread_id: ThreadId,      // Which thread holds the write lock
    lock_count: LockCount,    // How many transactions on this thread use it
}
```

**What it means:**
- Only **one thread** can hold a write lock at a time
- `lock_count` tracks how many transactions on that thread are using the account
- Multiple transactions on the **same thread** can share the write lock

### 4. **Read Lock Structure: `AccountReadLocks`**

```rust
// From thread_aware_account_locks.rs:29-32
struct AccountReadLocks {
    thread_set: ThreadSet,                    // Which threads have read locks
    lock_counts: [LockCount; MAX_THREADS],   // Lock count per thread
}
```

**What it means:**
- **Multiple threads** can hold read locks simultaneously
- `thread_set` is a bitmask tracking which threads have read locks
- `lock_counts[thread_id]` tracks how many transactions on each thread use the account

## What Happens When Locking Accounts

### Step 1: **Entry Point - `try_lock_accounts()`**

```rust
// From thread_aware_account_locks.rs:89-107
pub fn try_lock_accounts<'a>(
    &mut self,
    write_account_locks: impl Iterator<Item = &'a Pubkey>,
    read_account_locks: impl Iterator<Item = &'a Pubkey>,
    allowed_threads: ThreadSet,
    thread_selector: impl FnOnce(ThreadSet) -> ThreadId,
) -> Result<ThreadId, TryLockError> {
    // 1. Check which threads can schedule
    let schedulable_threads = self.accounts_schedulable_threads(...)?;
    
    // 2. Select best thread
    let thread_id = thread_selector(schedulable_threads);
    
    // 3. ACTUALLY LOCK accounts on that thread
    self.lock_accounts(write_account_locks, read_account_locks, thread_id);
    
    Ok(thread_id)
}
```

### Step 2: **Lock All Accounts - `lock_accounts()`**

```rust
// From thread_aware_account_locks.rs:206-223
fn lock_accounts<'a>(
    &mut self,
    write_account_locks: impl Iterator<Item = &'a Pubkey>,
    read_account_locks: impl Iterator<Item = &'a Pubkey>,
    thread_id: ThreadId,
) {
    // Lock all writable accounts
    for account in write_account_locks {
        self.write_lock_account(account, thread_id);
    }
    
    // Lock all read-only accounts
    for account in read_account_locks {
        self.read_lock_account(account, thread_id);
    }
}
```

### Step 3A: **Lock Write Account - `write_lock_account()`**

```rust
// From thread_aware_account_locks.rs:227-255
fn write_lock_account(&mut self, account: &Pubkey, thread_id: ThreadId) {
    // Get or create entry for this account
    let entry = self.locks.entry(*account).or_default();
    
    let AccountLocks { write_locks, read_locks } = entry;
    
    // Verify no conflicts (assertions in debug mode)
    if let Some(read_locks) = read_locks {
        assert_eq!(read_locks.thread_set.only_one_contained(), Some(thread_id));
    }
    
    if let Some(write_locks) = write_locks {
        // Account already write-locked on this thread
        assert_eq!(write_locks.thread_id, thread_id);
        write_locks.lock_count = write_locks.lock_count.wrapping_add(1);  // Increment count
    } else {
        // First write lock on this account
        *write_locks = Some(AccountWriteLocks {
            thread_id,
            lock_count: 1,
        });
    }
}
```

**What happens:**
1. **Get or create** entry in `locks` hashmap for the account
2. **Check conflicts**: Verify no read locks on other threads (panic if conflict)
3. **If already write-locked**: Increment `lock_count` (same thread, multiple transactions)
4. **If not write-locked**: Create new `AccountWriteLocks` with `lock_count = 1`

### Step 3B: **Lock Read Account - `read_lock_account()`**

```rust
// From thread_aware_account_locks.rs:289-317
fn read_lock_account(&mut self, account: &Pubkey, thread_id: ThreadId) {
    let AccountLocks { write_locks, read_locks } = 
        self.locks.entry(*account).or_default();
    
    // Verify no write locks on other threads
    if let Some(write_locks) = write_locks {
        assert_eq!(write_locks.thread_id, thread_id);
    }
    
    match read_locks {
        Some(read_locks) => {
            // Account already has read locks
            read_locks.thread_set.insert(thread_id);  // Add thread to set
            read_locks.lock_counts[thread_id] = 
                read_locks.lock_counts[thread_id].wrapping_add(1);  // Increment count
        }
        None => {
            // First read lock on this account
            let mut lock_counts = [0; MAX_THREADS];
            lock_counts[thread_id] = 1;
            *read_locks = Some(AccountReadLocks {
                thread_set: ThreadSet::only(thread_id),
                lock_counts,
            });
        }
    }
}
```

**What happens:**
1. **Get or create** entry in `locks` hashmap for the account
2. **Check conflicts**: Verify no write locks on other threads (panic if conflict)
3. **If already read-locked**: 
   - Add `thread_id` to `thread_set` (if not already present)
   - Increment `lock_counts[thread_id]`
4. **If not read-locked**: Create new `AccountReadLocks` with `lock_counts[thread_id] = 1`

## State Changes: Before and After

### Example 1: **Locking a Write Account (First Lock)**

**Before:**
```
locks: {
    // Account X not in hashmap (no locks)
}
```

**After locking Account X for write on Thread 2:**
```
locks: {
    Account X → AccountLocks {
        write_locks: Some(AccountWriteLocks {
            thread_id: 2,
            lock_count: 1
        }),
        read_locks: None
    }
}
```

**Effect:**
- Account X is now **write-locked** on Thread 2
- Only Thread 2 can schedule transactions that need Account X
- Other threads cannot acquire locks on Account X

### Example 2: **Locking a Read Account (First Lock)**

**Before:**
```
locks: {
    // Account Y not in hashmap (no locks)
}
```

**After locking Account Y for read on Thread 1:**
```
locks: {
    Account Y → AccountLocks {
        write_locks: None,
        read_locks: Some(AccountReadLocks {
            thread_set: ThreadSet(0b0010),  // Thread 1 bit set
            lock_counts: [0, 1, 0, 0, ...]  // Count = 1 for thread 1
        })
    }
}
```

**Effect:**
- Account Y is now **read-locked** on Thread 1
- All threads can still acquire read locks (parallel reads allowed)
- No threads can acquire write locks until all read locks are released

### Example 3: **Multiple Transactions on Same Thread (Write Lock)**

**Initial state:**
```
locks: {
    Account X → AccountLocks {
        write_locks: Some(AccountWriteLocks {
            thread_id: 2,
            lock_count: 1  // Transaction 1 using it
        }),
        read_locks: None
    }
}
```

**After Transaction 2 (same thread) locks Account X:**
```
locks: {
    Account X → AccountLocks {
        write_locks: Some(AccountWriteLocks {
            thread_id: 2,
            lock_count: 2  // Both transactions using it
        }),
        read_locks: None
    }
}
```

**Effect:**
- `lock_count` incremented to 2
- Both transactions can use Account X on Thread 2
- When Transaction 1 completes, `lock_count` decrements to 1
- When Transaction 2 completes, `lock_count` decrements to 0, entry removed

### Example 4: **Multiple Threads Reading Same Account**

**Initial state:**
```
locks: {
    Account Y → AccountLocks {
        write_locks: None,
        read_locks: Some(AccountReadLocks {
            thread_set: ThreadSet(0b0010),  // Thread 1
            lock_counts: [0, 1, 0, 0, ...]
        })
    }
}
```

**After Thread 3 locks Account Y for read:**
```
locks: {
    Account Y → AccountLocks {
        write_locks: None,
        read_locks: Some(AccountReadLocks {
            thread_set: ThreadSet(0b1010),  // Threads 1 and 3
            lock_counts: [0, 1, 0, 1, ...]  // Count = 1 for each
        })
    }
}
```

**Effect:**
- `thread_set` updated to include Thread 3
- `lock_counts[3]` set to 1
- Both threads can read Account Y in parallel
- No threads can write until all read locks are released

## How Locking Affects Schedulability

### **Write Lock Effects:**

```rust
// From thread_aware_account_locks.rs:167-203
fn schedulable_threads<const WRITE: bool>(&self, account: &Pubkey) -> ThreadSet {
    match self.locks.get(account) {
        None => ThreadSet::any(self.num_threads),  // No locks: any thread
        
        Some(AccountLocks {
            write_locks: Some(write_locks),
            ..
        }) => ThreadSet::only(write_locks.thread_id),  // Only that thread
    }
}
```

**Impact:**
- **Write-locked account**: Only the thread holding the write lock can schedule transactions needing it
- **Other threads**: Cannot schedule transactions that need write or read access

### **Read Lock Effects:**

```rust
Some(AccountLocks {
    write_locks: None,
    read_locks: Some(read_locks),
}) => {
    if WRITE {
        // Write blocked by reads
        ThreadSet::none()
    } else {
        // Reads allowed in parallel
        ThreadSet::any(self.num_threads)
    }
}
```

**Impact:**
- **Read-locked account**: All threads can still acquire read locks (parallel reads)
- **Write requests**: Blocked until all read locks are released
- **Read requests**: Allowed on any thread

## Lock Count Management

### **Why Lock Counts Matter:**

Lock counts track **how many transactions** on a thread are using an account:

```rust
// When locking
write_locks.lock_count = write_locks.lock_count.wrapping_add(1);

// When unlocking (from write_unlock_account)
write_locks.lock_count = write_locks.lock_count.wrapping_sub(1);
if write_locks.lock_count == 0 {
    *maybe_write_locks = None;  // Remove lock entry
    if read_locks.is_none() {
        entry.remove();  // Remove account entry entirely
    }
}
```

**Purpose:**
- **Multiple transactions** on the same thread can share locks
- Lock is only **released** when `lock_count` reaches 0
- Prevents premature unlocking when multiple transactions use the same account

## Summary: What Actually Happens

| Action | Data Structure Change | Effect |
|--------|----------------------|--------|
| **Lock write account (first)** | Create `AccountWriteLocks` with `lock_count=1` | Account exclusive to that thread |
| **Lock write account (same thread)** | Increment `lock_count` | Multiple transactions share lock |
| **Lock read account (first)** | Create `AccountReadLocks` with `thread_set` and `lock_counts` | Account readable by all threads |
| **Lock read account (new thread)** | Add thread to `thread_set`, increment `lock_counts[thread_id]` | Parallel reads allowed |
| **Unlock account** | Decrement `lock_count`, remove entry if count reaches 0 | Account becomes available |

**Key Points:**

1. **Hashmap entries created**: Accounts are added to `locks` hashmap when first locked
2. **Lock counts incremented**: Each lock increments the count for that thread
3. **Thread sets updated**: Read locks update `thread_set` bitmask
4. **Conflict prevention**: Locks prevent other threads from acquiring conflicting locks
5. **Schedulability affected**: Lock state determines which threads can schedule transactions
6. **Reference counting**: Lock counts track multiple transactions using the same account
7. **Cleanup on unlock**: Entries removed when lock counts reach 0The locking mechanism creates a **thread-aware reservation system** that enables safe parallel execution by tracking exactly which threads have access to which accounts, preventing conflicts while maximizing parallelism.
