Q1： what is a priority graph?
A Priority Graph is a data structure that:
1) Stores transactions with their account access information
2) Tracks conflicts between transactions based on shared accounts
3) Maintains priority ordering (highest priority transactions first)
4) Manages blocking relationships (when transactions block each other)


Q2: Data structure 

type SchedulePrioGraph = PrioGraph<
    TransactionPriorityId, //Node: Transaction ID with priority 
    Pubkey,            //Edge: Account(resource) that connects transactions
    TransactionPriorityId,  //Value stored in graph 
    PriorityFunction     //Function to determine priority
>;

Think of it as:
Nodes = Transactions (with priority)
Edges = Account conflicts (transactions sharing accounts)
Graph = Relationships showing which transactions conflict


Q3: How conflicts between transactions are maintained in a priority graph ? 

Conflicts between transactions are maintained in a priority graph through **edges** that connect transactions sharing the same accounts. Here's how it works:

## 1. **Edge Creation During Insertion**

When a transaction is inserted into the `PrioGraph` via `insert_transaction()`:
- **Input**: Transaction ID (with priority) + Account access information (Pubkey + AccessKind)
- **Process**: The graph automatically creates edges between the new transaction and existing transactions that access the same accounts
- **Edge Label**: The `Pubkey` (account) that connects the transactions

**Code location**: `prio_graph_scheduler.rs:198-201`
```rust
prio_graph.insert_transaction(
    *id,
    Self::get_transaction_account_access(transaction),  // Iterator of (Pubkey, AccessKind)
);
```

## 2. **Account Access Information**

Each transaction provides its account access pattern:
- **Read access**: `(Pubkey, AccessKind::Read)` - for accounts that are read-only
- **Write access**: `(Pubkey, AccessKind::Write)` - for accounts that are writable

**Code location**: `prio_graph_scheduler.rs:380-394`
```rust
fn get_transaction_account_access(message: &impl SVMMessage) 
    -> impl Iterator<Item = (Pubkey, AccessKind)> + '_ {
    message.account_keys().iter().enumerate().map(|(index, key)| {
        if message.is_writable(index) {
            (*key, AccessKind::Write)
        } else {
            (*key, AccessKind::Read)
        }
    })
}
```

## 3. **Conflict Detection Rules**

The graph maintains conflicts based on account sharing:
- **Two transactions conflict** if they access the same account (`Pubkey`)
- **Edge represents conflict**: An edge between two transaction nodes means they conflict on that account
- **Multiple edges possible**: Transactions can have multiple edges if they share multiple accounts

## 4. **Priority-Based Ordering**

When transactions are popped from the graph (`prio_graph.pop()`):
- Transactions are returned in **priority order** (highest priority first)
- The graph respects the conflict relationships when determining scheduling order
- Higher priority transactions are scheduled before lower priority ones, even if they conflict

## 5. **Conflict Maintenance During Scheduling**

During the scheduling process:
- **Look-ahead window**: Transactions are inserted into the graph in batches (up to `look_ahead_window_size`)
- **Conflict checking**: When scheduling, transactions check for conflicts with:
  - Already executing transactions (via `account_locks`)
  - Blocked transactions (via `blocking_locks`)
- **Blocking mechanism**: If a transaction conflicts with a higher-priority blocked transaction, it also becomes blocked to maintain priority order

**Code location**: `prio_graph_scheduler.rs:446-458`
```rust
// Check if this transaction conflicts with any blocked transactions
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

## Summary

Conflicts are maintained through:
1. **Graph edges** connecting transactions that share accounts (Pubkey)
2. **Automatic edge creation** when transactions are inserted with their account access patterns
3. **Priority ordering** that ensures higher priority transactions are scheduled first
4. **Blocking mechanism** that prevents priority inversion when conflicts occur


Q4: Are all transactions in the priority graph blocked transactions?

**No, not all transactions in the graph are blocked.** The priority graph contains transactions in different states:

## Transaction States in the Graph

### 1. **New/Unprocessed Transactions** (Not Blocked)
- Transactions are initially inserted into the graph during the **look-ahead window** phase
- These transactions haven't been attempted for scheduling yet
- They are candidates waiting to be popped and scheduled

**Code location**: `prio_graph_scheduler.rs:198-201`
```rust
// Transactions are inserted into graph from container
prio_graph.insert_transaction(
    *id,
    Self::get_transaction_account_access(transaction),
);
```

### 2. **Ready-to-Schedule Transactions** (Not Blocked)
- Transactions that are popped from the graph (`prio_graph.pop()`) and successfully scheduled
- These transactions are marked as "unblocked" after being sent to execution threads
- They represent transactions that can be scheduled without conflicts

**Code location**: `prio_graph_scheduler.rs:244-247, 332-333`
```rust
while let Some(id) = self.prio_graph.pop() {
    // Transaction is popped and attempted to schedule
    unblock_this_batch.push(id);
    // ... scheduling attempt ...
    
    // After successful scheduling, transaction is unblocked
    self.prio_graph.unblock(&id);
}
```

### 3. **Blocked Transactions** (Blocked)
- Transactions that **fail** to schedule due to conflicts become blocked
- Their account locks are added to `blocking_locks` to prevent priority inversion
- These transactions remain in the graph but are blocked from being scheduled until conflicts clear

**Code location**: `prio_graph_scheduler.rs:454-457`
```rust
if !blocking_locks.check_locks(transaction) {
    blocking_locks.take_locks(transaction);  // Transaction becomes blocked
    return Err(TransactionSchedulingError::UnschedulableConflicts);
}
```

## Key Distinction

- **`blocking_locks`** (separate data structure): Tracks accounts locked by **unschedulable/blocked** transactions
- **`prio_graph`**: Contains **all** transactions (blocked and unblocked) with their conflict relationships

## Lifecycle Example

1. **Insertion**: Transaction A is inserted into graph → **Not blocked** (just added)
2. **Scheduling attempt**: Transaction A is popped and tried to schedule
3. **Success**: Transaction A schedules successfully → **Unblocked** and removed from graph
4. **Failure**: Transaction A conflicts → Added to `blocking_locks` → **Blocked** (remains in graph)
5. **Retry**: In next scheduling pass, Transaction A is retried → May succeed or remain blocked

## Summary

- **Graph contains**: All transactions (blocked + unblocked + new)
- **Blocked transactions**: Only those that failed to schedule due to conflicts
- **Most transactions**: Are not blocked - they're either new candidates or successfully scheduled



