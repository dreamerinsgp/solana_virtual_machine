Q1: what's the purpose of this test ? 
To verify 
1) Multiple NOn-conflicting transactions can be batched together 

(Non-conflicting transactions) means transactions with unique accounts. 



Q2: What does this test do? 
1) run two transactions on a single thread. 
2) two transaction are batched together in the same batch.
3) they execute sequentially on that thread (not in parallel).



Q3: test data logs
1) two transactions 
Transaction ID 0:
  All accounts: [2iXDkcuoU5tgG51BrnM5C6L9W5K1bHxQ4vPq3wEmRgjA, 11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs, 11111111111111111111111111111111, ComputeBudget111111111111111111111111111111]
  Write accounts: [2iXDkcuoU5tgG51BrnM5C6L9W5K1bHxQ4vPq3wEmRgjA, 11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs]
  Read accounts: [11111111111111111111111111111111, ComputeBudget111111111111111111111111111111]

Transaction ID 1:
  All accounts: [HuSTr2kREtwiFQrfzbCMMV51UXb8RJxTfNyAkk4Qu536, 1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG, 11111111111111111111111111111111, ComputeBudget111111111111111111111111111111]
  Write accounts: [HuSTr2kREtwiFQrfzbCMMV51UXb8RJxTfNyAkk4Qu536, 1117mWrzzrZr312ebPDHu8tbfMwFNvCvMbr6WepCNG]
  Read accounts: [11111111111111111111111111111111, ComputeBudget111111111111111111111111111111]

2) Budget
a: Total budget = Kitchen's total cooking capacity
The kitchen can handle 50,000 "cooking units" per hour
This is the total compute capacity for the block

b: In-flight CUs = Orders currently being cooked
Some orders are already on the stove/grill
These consume cooking capacity right now
Example: 10,000 cooking units are being used for orders in progress

c: Available budget = Remaining cooking capacity
How much capacity is left for new orders?


Q4:Threades 
1) How to get the number of threads?
let num_threads = self.common.consume_work_senders.len();

2) How max_cu_per_thread is calculated?
let max_cu_per_thread = self.config.max_scheduled_cus / num_threads as u64;

Example: 
max_scheduled_cus = 60,000,000
num_threads = 4
max_cu_per_thread = 60,000,000 / 4 = 15,000,000 CUs per thread

3) why take this way to evenly distribute the total block compute capacity across all worker threads. 
a.Each thread has a fair share of capacity
b.No single thread exceeds its allocated portion
c.Total capacity across all threads equals max_scheduled_cus


4) How to get current thread cu consumption ? 
self.common.in_flight_tracker.cus_in_flight_per_thread()[thread_id]







Q5: How two transactions are scheduled ? 





### 2. `test_schedule_single_threaded_no_conflicts` (Line 597)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:597-616`

**Purpose:** Tests basic scheduling functionality with a single thread and no account conflicts.

**What it tests:**
- Schedules 2 transactions that don't conflict (each uses unique accounts)
- Verifies that both transactions are scheduled successfully
- Confirms transactions are sent to the correct worker thread

**Key assertions:**
- `num_scheduled == 2`
- `num_unschedulable_conflicts == 0`
- Transactions are properly batched and sent to thread 0

**Test setup:**
- 1 worker thread
- 2 transactions with unique accounts (no conflicts)
- Unlimited budget (`u64::MAX`)

---

## Parameter Meanings

### 1. `create_test_frame(1)`
**Function:** `create_test_frame(num_threads: usize)`

**Parameters:**
- `num_threads: usize` - Number of worker threads to create (in this test: `1`)

**Returns:** A tuple containing:
- `scheduler: PrioGraphScheduler<...>` - The scheduler instance
- `work_receivers: Vec<Receiver<ConsumeWork<...>>>` - Receivers for each worker thread to receive scheduled work
- `finished_work_sender: Sender<FinishedConsumeWork<...>>` - Sender to notify scheduler when work is completed

**Purpose:** Creates a test environment with:
- Communication channels between scheduler and worker threads
- A configured `PrioGraphScheduler` instance
- Default scheduler configuration

---

### 2. `create_container([...])`
**Function:** `create_container(tx_infos: impl IntoIterator<Item = (Keypair, [Pubkey], u64, u64)>)`

**Parameters:** An array of tuples, each tuple represents a transaction with:
```rust
(
    &Keypair::new(),                    // 1. from_keypair: Keypair to sign the transaction
    &[Pubkey::new_unique()],            // 2. to_pubkeys: Array of destination pubkeys (accounts to transfer to)
    1,                                  // 3. lamports: Amount of lamports to transfer
    1,                                  // 4. compute_unit_price: Priority fee (compute unit price)
)
```

**Tuple Element Details:**

1. **`from_keypair: &Keypair`**
   - The keypair used to sign and send the transaction
   - In the test: `&Keypair::new()` creates a new random keypair for each transaction
   - This is the sender's account

2. **`to_pubkeys: &[Pubkey]`**
   - Array of destination public keys (recipient accounts)
   - In the test: `&[Pubkey::new_unique()]` creates a unique pubkey for each transaction
   - These are the accounts that will receive the lamports
   - Multiple pubkeys can be specified for multi-recipient transfers

3. **`lamports: u64`**
   - Amount of lamports (SOL) to transfer
   - In the test: `1` lamport for first transaction, `2` lamports for second transaction
   - 1 SOL = 1,000,000,000 lamports

4. **`compute_unit_price: u64`**
   - Priority fee (compute unit price) for the transaction
   - Higher values = higher priority
   - In the test: `1` for first transaction, `2` for second transaction
   - This determines transaction priority in the scheduler

**Returns:** `TransactionStateContainer<RuntimeTransaction<SanitizedTransaction>>`
- A container holding the transaction states
- Transactions are inserted with their metadata (priority, cost, etc.)

**In the test:**
```rust
create_container([
    (&Keypair::new(), &[Pubkey::new_unique()], 1, 1),  // Transaction 0: priority=1, amount=1
    (&Keypair::new(), &[Pubkey::new_unique()], 2, 2),  // Transaction 1: priority=2, amount=2
])
```
- Creates 2 transactions with unique accounts (no conflicts)
- Transaction 0 has priority 1, Transaction 1 has priority 2
- Since accounts are unique, they can be scheduled together

---

### 3. `scheduler.schedule(...)`
**Function:** `schedule<S: StateContainer<Tx>>(...)`

**Parameters:**

1. **`&mut container`**
   - Type: `&mut S` where `S: StateContainer<Tx>`
   - The container holding transactions to be scheduled
   - Modified during scheduling (transactions are removed as they're scheduled)

2. **`budget: u64`**
   - Type: `u64`
   - Compute unit budget available for scheduling
   - In the test: `u64::MAX` (unlimited budget)
   - Limits how many compute units can be scheduled
   - If budget is 0, no transactions will be scheduled

3. **`relax_intrabatch_account_locks: bool`**
   - Type: `bool`
   - Feature flag for relaxing account locks within a batch
   - In the test: `false` (standard locking behavior)
   - When `true`, allows transactions in the same batch to share accounts

4. **`pre_graph_filter: impl Fn(&[&Tx], &mut [bool])`**
   - Type: Closure/function that filters transactions before they enter the priority graph
   - In the test: `test_pre_graph_filter` - accepts all transactions (sets all results to `true`)
   - Parameters:
     - `&[&Tx]` - Slice of transaction references
     - `&mut [bool]` - Mutable slice of boolean results (true = keep, false = filter out)
   - Used to filter transactions based on age, validity, etc.

5. **`pre_lock_filter: impl Fn(&TransactionState<Tx>) -> PreLockFilterAction`**
   - Type: Closure/function that filters transactions before attempting to lock accounts
   - In the test: `test_pre_lock_filter` - always returns `AttemptToSchedule`
   - Parameter: `&TransactionState<Tx>` - The transaction state being evaluated
   - Returns: `PreLockFilterAction::AttemptToSchedule` - indicates transaction should be scheduled
   - Used for additional filtering before account locking

**Returns:** `Result<SchedulingSummary, SchedulerError>`
- `SchedulingSummary` contains:
  - `num_scheduled: usize` - Number of transactions successfully scheduled
  - `num_unschedulable_conflicts: usize` - Number of transactions blocked by conflicts
  - `num_unschedulable_threads: usize` - Number of transactions blocked by thread capacity
  - `num_filtered_out: usize` - Number of transactions filtered out
  - `starting_queue_size: usize` - Queue size before scheduling
  - `starting_buffer_size: usize` - Buffer size before scheduling

---

## Test Flow Summary

1. **Setup:**
   - Create scheduler with 1 worker thread
   - Create container with 2 transactions (unique accounts, priorities 1 and 2)

2. **Schedule:**
   - Call `schedule()` with unlimited budget
   - Both transactions pass filters (no filtering)
   - Both transactions are scheduled (no conflicts, sufficient budget)

3. **Verify:**
   - `num_scheduled == 2` ✓
   - `num_unschedulable_conflicts == 0` ✓
   - Both transactions are batched together: `vec![vec![1, 0]]`
     - Transaction IDs `[1, 0]` are in the same batch
     - Sent to thread 0 (the only thread)

---

## Helper Functions Used

- **`test_pre_graph_filter`**: Accepts all transactions (no filtering)
- **`test_pre_lock_filter`**: Always attempts to schedule (no filtering)
- **`collect_work(receiver)`**: Collects work sent to a worker thread and returns transaction IDs
