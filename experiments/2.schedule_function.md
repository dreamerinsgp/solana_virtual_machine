# Test Functions for `schedule()` in PrioGraphScheduler

This document lists all test functions that test the `schedule()` function in `prio_graph_scheduler.rs` and explains the purpose of each test.

## Test Functions Overview

### 1. `test_schedule_disconnected_channel` (Line 579)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:579-594`

**Purpose:** Tests error handling when the work receiver channel is disconnected.

**What it tests:**
- Verifies that `schedule()` returns `SchedulerError::DisconnectedSendChannel` when trying to send work to a disconnected channel
- Ensures proper error handling when worker threads are no longer available

**Key assertions:**
- `schedule()` should return an error when receivers are dropped

---

### 2. `test_schedule_single_threaded_no_conflicts` (Line 597)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:597-616`

**Purpose:** Tests basic scheduling functionality with a single thread and no account conflicts.

**What it tests:**
- Schedules 2 transactions that don't conflict (each uses unique accounts)
- Verifies that both transactions are scheduled successfully
- Confirms transactions are sent to the correct worker thread

**Key assertions:**
- `num_scheduled == 2`
- `num_unschedulable_conflicts == 0`
- Transactions are properly batched and sent to thread 0

**Test setup:**
- 1 worker thread
- 2 transactions with unique accounts (no conflicts)
- Unlimited budget (`u64::MAX`)

---

### 3. `test_schedule_budget` (Line 619)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:619-637`

**Purpose:** Tests that scheduling respects budget constraints.

**What it tests:**
- Verifies that when budget is 0, no transactions are scheduled
- Ensures budget limits are properly enforced

**Key assertions:**
- `num_scheduled == 0` when budget is 0
- `num_unschedulable_conflicts == 0` (not a conflict issue, just budget)

**Test setup:**
- 1 worker thread
- 2 transactions available
- Budget = 0 (should schedule nothing)

---

### 4. `test_schedule_single_threaded_conflict` (Line 640)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:640-660`

**Purpose:** Tests scheduling transactions that share accounts (conflicts) on a single thread.

**What it tests:**
- Schedules 2 transactions that both use the same account (conflict)
- Verifies that conflicting transactions are still schedulable on the same thread
- Confirms transactions are scheduled in separate batches (sequential execution)

**Key assertions:**
- `num_scheduled == 2` (both scheduled despite conflict)
- `num_unschedulable_conflicts == 0` (conflicts resolved by same-thread scheduling)
- Transactions are in separate batches: `vec![vec![1], vec![0]]`

**Test setup:**
- 1 worker thread
- 2 transactions sharing the same account
- Unlimited budget

---

### 5. `test_schedule_consume_single_threaded_multi_batch` (Line 663)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:663-691`

**Purpose:** Tests scheduling multiple batches of transactions on a single thread.

**What it tests:**
- Schedules a large number of transactions (4 × `TARGET_NUM_TRANSACTIONS_PER_BATCH`)
- Verifies that transactions are properly batched
- Confirms all batches are sent to the same thread

**Key assertions:**
- `num_scheduled == 4 * TARGET_NUM_TRANSACTIONS_PER_BATCH`
- `num_unschedulable_conflicts == 0`
- 4 batches are created, each with `TARGET_NUM_TRANSACTIONS_PER_BATCH` transactions

**Test setup:**
- 1 worker thread
- 4 × `TARGET_NUM_TRANSACTIONS_PER_BATCH` transactions
- Unlimited budget

---

### 6. `test_schedule_simple_thread_selection` (Line 694)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:694-712`

**Purpose:** Tests thread selection logic when multiple threads are available.

**What it tests:**
- Schedules 4 transactions across 2 threads
- Verifies that transactions are distributed across threads (round-robin or load balancing)
- Confirms thread selection works correctly

**Key assertions:**
- `num_scheduled == 4`
- `num_unschedulable_conflicts == 0`
- Transactions distributed: thread 0 gets `[3, 1]`, thread 1 gets `[2, 0]`

**Test setup:**
- 2 worker threads
- 4 transactions with unique accounts
- Unlimited budget

---

### 7. `test_schedule_priority_guard` (Line 715)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:715-795`

**Purpose:** Tests the priority guard mechanism that prevents scheduling lower-priority transactions when higher-priority ones are unschedulable.

**What it tests:**
- Tests behavior with a shortened look-ahead window (causing some transactions to be unschedulable)
- Verifies that when high-priority transactions are unschedulable due to conflicts, lower-priority transactions that conflict with them are also not scheduled (priority guard)
- Tests that transactions become schedulable after completing work and releasing locks

**Key assertions:**
- First pass: `num_scheduled == 4`, `num_unschedulable_conflicts == 2`
- Second pass (before completion): `num_scheduled == 0` (still blocked)
- After completing work on thread 0: `num_scheduled == 2` (remaining transactions can be scheduled)

**Test setup:**
- 2 worker threads
- 6 transactions with complex conflict relationships
- Look-ahead window size = 2 (intentionally small to create conflicts)
- Creates a priority graph where transactions [4] and [5] are blocked by higher-priority transactions [0] and [1] scheduled on different threads

**Priority Graph Structure:**
```
[0] \
     -> [4] -> [5]
[1] / ------/
[2]
[3]
```

---

### 8. `test_schedule_over_full_container` (Line 798)
**Code Location:** `core/src/banking_stage/transaction_scheduler/prio_graph_scheduler.rs:798-840`

**Purpose:** Tests scheduling behavior when the container has more transactions than can be processed in a single scheduling pass.

**What it tests:**
- Verifies that `max_scanned_transactions_per_scheduling_pass` limit is respected
- Ensures that transactions beyond the limit remain in the container for future passes
- Confirms that scheduling doesn't exceed the configured scan limit

**Key assertions:**
- `num_scheduled == min(capacity, max_scanned_transactions_per_scheduling_pass)`
- `num_unschedulable_conflicts == 0`
- Remaining transactions stay in container: `capacity - expected_num_scheduled`

**Test setup:**
- 1 worker thread
- Container size = `max_scanned_transactions_per_scheduling_pass + 2`
- Unlimited budget
- Verifies that only `max_scanned_transactions_per_scheduling_pass` transactions are scheduled per pass

---

## Summary

These tests cover:
1. **Error handling** - Disconnected channels
2. **Basic functionality** - Simple scheduling without conflicts
3. **Budget constraints** - Budget limit enforcement
4. **Conflict resolution** - Same-thread conflict handling
5. **Batching** - Multiple batch creation
6. **Thread selection** - Multi-thread distribution
7. **Priority guards** - Preventing lower-priority scheduling when higher-priority is blocked
8. **Scan limits** - Respecting per-pass transaction limits

All tests use helper functions:
- `create_test_frame(num_threads)` - Creates scheduler with specified number of worker threads
- `create_container(transactions)` - Creates a container with test transactions
- `test_pre_graph_filter` - Filter that accepts all transactions
- `test_pre_lock_filter` - Filter that attempts to schedule all transactions
- `collect_work(receiver)` - Collects work sent to a worker thread
